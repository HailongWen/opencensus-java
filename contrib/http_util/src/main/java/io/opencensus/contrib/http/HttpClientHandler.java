/*
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.opencensus.contrib.http;

import static com.google.common.base.Preconditions.checkNotNull;

import io.opencensus.trace.MessageEvent.Type;
import io.opencensus.trace.Span;
import io.opencensus.trace.SpanContext;
import io.opencensus.trace.Tracer;
import io.opencensus.trace.propagation.TextFormat;
import javax.annotation.Nullable;

/**
 * This helper class provides APIs for instrumenting HTTP clients.
 *
 * @since 0.13
 */
public class HttpClientHandler<Q, P> extends HttpHandler<Q, P> {

  /**
   * Creates a {@link HttpClientHandler} with given parameters.
   *
   * @param tracer the Open Census tracing component.
   * @param textFormat the {@code TextFormat} used in HTTP propagation.
   * @param extractor the {@code HttpExtractor} used to extract information from the
   *     request/response.
   * @since 0.13
   */
  public HttpClientHandler(Tracer tracer, TextFormat textFormat, HttpExtractor<Q, P> extractor) {
    super(tracer, textFormat, extractor);
  }

  @Override
  public String getSpanName(Q request, String method) {
    return String.format("Sent.%s", method);
  }

  /**
   * Instrument a request before it is sent. By default it will propagate the context of the span
   * and record the message size.
   *
   * <p>This method will create a span in current context to represent the send process. The created
   * span will be propagated to the server.
   *
   * <p>The name of the span would be generated by invoking {@link #getSpanName} with the parameter
   * {@code method}.
   *
   * <p>The generated span will NOT be set as current context. User can use the returned value to
   * control when to enter the scope of this span.
   *
   * @param <C> the type of the carrier.
   * @param setter the setter used when injecting information to the {@code carrier}.
   * @param carrier the entity that holds the HTTP information.
   * @param request the request entity.
   * @param method the name of the send method.
   * @return a span that represents the request process.
   * @since 0.13
   */
  public <C> Span handleSend(TextFormat.Setter<C> setter, C carrier, Q request, String method) {
    checkNotNull(setter, "setter");
    checkNotNull(carrier, "carrier");
    checkNotNull(request, "request");
    Span span = tracer.spanBuilder(getSpanName(request, method)).startSpan();
    handleSend(setter, carrier, request, span);
    return span;
  }

  /**
   * Instrument a request before it is sent. By default it will propagate the context of the span
   * and record the message size.
   *
   * <p>Unlike the other method, this one will reuse an existing span. The {@code SpanContext} in
   * the span will be propagated to the server.
   *
   * @param <C> the type of the carrier.
   * @param setter the setter used when injecting information to the {@code carrier}.
   * @param carrier the entity that holds the HTTP information.
   * @param request the request entity.
   * @param span the span that represents the request process.
   * @since 0.13
   */
  public <C> void handleSend(TextFormat.Setter<C> setter, C carrier, Q request, Span span) {
    checkNotNull(setter, "setter");
    checkNotNull(carrier, "carrier");
    checkNotNull(request, "request");
    checkNotNull(span, "span");
    // inject propagation header
    SpanContext spanContext = span.getContext();
    if (!spanContext.equals(SpanContext.INVALID)) {
      textFormat.inject(spanContext, carrier, setter);
    }
    // record message size
    recordMessageEvent(
        span, nextSentMessageEventId(), Type.SENT, extractor.getRequestSize(request), 0L);
  }

  /**
   * Instrument a request after its response is recevied. By default it will handle error, set the
   * status of the span and optionally end the span.
   *
   * @param response the received response.
   * @param error the error occurs when processing the response.
   * @param span the span that represents the request.
   * @param endSpan whether to end the span.
   * @since 0.13
   */
  public void handleRecv(
      @Nullable P response, @Nullable Throwable error, Span span, boolean endSpan) {
    checkNotNull(span, "span");
    // record message size
    recordMessageEvent(
        span, nextRecvMessageEventId(), Type.RECEIVED, extractor.getResponseSize(response), 0L);

    // set status according to response
    span.setStatus(parseResponseStatus(response, error));

    // maybe end span
    if (endSpan) {
      span.end();
    }
  }
}
